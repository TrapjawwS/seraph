{
  "version": 3,
  "sources": ["../../../server/private-messages/database.ts"],
  "sourcesContent": ["/**\n * Storage handling for offline PMs.\n * By Mia.\n * @author mia-pi-git\n */\nimport {SQL, FS} from '../../lib';\nimport {EXPIRY_TIME, SEEN_EXPIRY_TIME, MAX_PENDING} from '.';\n\nexport const functions: {[k: string]: (...args: any) => any} = {\n\tshould_expire: (time) => {\n\t\tconst diff = Date.now() - time;\n\t\tif (diff > EXPIRY_TIME) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t},\n\tseen_duration: (seen) => {\n\t\tif (!seen) return 0;\n\t\tconst diff = Date.now() - seen;\n\t\tif (diff >= SEEN_EXPIRY_TIME) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t},\n};\n\nexport const statements: {[k: string]: string} = {\n\tsend: 'INSERT INTO offline_pms (sender, receiver, message, time) VALUES (?, ?, ?, ?)',\n\tclear: 'DELETE FROM offline_pms WHERE receiver = ?',\n\tfetch: 'SELECT * FROM offline_pms WHERE receiver = ?',\n\tfetchNew: 'SELECT * FROM offline_pms WHERE receiver = ? AND seen IS NULL',\n\tclearDated: 'DELETE FROM offline_pms WHERE EXISTS (SELECT * FROM offline_pms WHERE should_expire(time) = 1)',\n\tcheckSentCount: 'SELECT count(*) as count FROM offline_pms WHERE sender = ? AND receiver = ?',\n\tsetSeen: 'UPDATE offline_pms SET seen = ? WHERE receiver = ?',\n\tclearSeen: 'DELETE FROM offline_pms WHERE seen_duration(seen) = 1',\n\tgetSettings: 'SELECT * FROM pm_settings WHERE userid = ?',\n\tsetBlock: 'REPLACE INTO pm_settings (userid, view_only) VALUES (?, ?)',\n\tdeleteSettings: 'DELETE FROM pm_settings WHERE userid = ?',\n};\n\nclass StatementMap {\n\tenv: SQL.TransactionEnvironment;\n\tconstructor(env: SQL.TransactionEnvironment) {\n\t\tthis.env = env;\n\t}\n\trun(name: string, args: any[] | AnyObject) {\n\t\treturn this.getStatement(name).run(args);\n\t}\n\tall(name: string, args: any[] | AnyObject) {\n\t\treturn this.getStatement(name).all(args);\n\t}\n\tget(name: string, args: any[] | AnyObject) {\n\t\treturn this.getStatement(name).get(args);\n\t}\n\tgetStatement(name: string) {\n\t\tconst source = statements[name];\n\t\treturn this.env.statements.get(source)!;\n\t}\n}\n\nexport const transactions: {\n\t[k: string]: (args: any[], env: SQL.TransactionEnvironment) => any,\n} = {\n\tsend: (args, env) => {\n\t\tconst statementList = new StatementMap(env);\n\t\tconst [sender, receiver, message] = args;\n\t\tconst count = statementList.get('checkSentCount', [sender, receiver])?.count;\n\t\tif (count && count > MAX_PENDING) {\n\t\t\treturn {error: `You have already sent the maximum ${MAX_PENDING} offline PMs to that user.`};\n\t\t}\n\t\treturn statementList.run('send', [sender, receiver, message, Date.now()]);\n\t},\n\tlistNew: (args, env) => {\n\t\tconst list = new StatementMap(env);\n\t\tconst [receiver] = args;\n\t\tconst pms = list.all('fetchNew', [receiver]);\n\t\tlist.run('setSeen', [Date.now(), receiver]);\n\t\treturn pms;\n\t},\n};\n\nexport function onDatabaseStart(database: import('better-sqlite3').Database) {\n\tlet version;\n\ttry {\n\t\tversion = database.prepare('SELECT * FROM db_info').get().version;\n\t} catch {\n\t\tconst schemaContent = FS('databases/schemas/pms.sql').readSync();\n\t\tdatabase.exec(schemaContent);\n\t}\n\tconst migrations = FS('databases/migrations/pms').readdirIfExistsSync();\n\tif (version !== migrations.length) {\n\t\tfor (const migration of migrations) {\n\t\t\tconst num = /(\\d+)\\.sql$/.exec(migration)?.[1];\n\t\t\tif (!num || version >= num) continue;\n\t\t\tdatabase.exec('BEGIN TRANSACTION');\n\t\t\ttry {\n\t\t\t\tdatabase.exec(FS(`databases/migrations/pms/${migration}`).readSync());\n\t\t\t} catch (e: any) {\n\t\t\t\tconsole.log(`Error in PM migration ${migration} - ${e.message}`);\n\t\t\t\tconsole.log(e.stack);\n\t\t\t\tdatabase.exec('ROLLBACK');\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdatabase.exec('COMMIT');\n\t\t}\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
